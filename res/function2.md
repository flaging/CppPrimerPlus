# [function2]函数探幽

## 1.内联函数

内联函数用于提高函数的运行速度。

### 1.1内联函数的与普通函数的不同

常规函数调用方式如下所述：

* 程序运行至某一函数，获得其地址
* 保存当前内存地址，至堆栈
* 将函数参数复制到堆栈
* 跳转到函数函数起点，执行程序
* 程序执行结束，将返回值放入寄存器
* 程序返回原地址，继续执行下一指令

内联函数用于省略该部分跳转，以提高程序运行速度。

内联函数的特点：

* 函数体足够短（通常多行程序不适合作为内联）
* 内联函数不能进行递归运算
* 内联只是程序的请求，是否内联看编译器

### 1.2内联函数的使用

内联的实现：使用关键词inline。

```C++
inline double fun1(double x){return x*x};
double a = fun1(10.0);

//内联的一个例子
double c = 10.0;
double b = fun1(c++);
cout << c << endl;  //这里c为11.0，若是正常函数，c传入后为局部变量，c++部分不会影响定义的c的值，c还为10.0
```

### 1.3内联函数和宏定义的不同

不同在于：

* 内联函数实质上还是函数
* 宏定义实质上是文本替代，不考虑前后文

```C++
#define fun2(x) x*x
double d = fun2(4.5+7.5); 
//d = 4.5 + 7.5 * 4.5 + 7.5 而不是d = (4.5 + 7.5) * (4.5 + 7.5)
```

## 2.函数的默认参数

函数的默认参数用于函数实参未赋值时调用的一个默认值。

相关要点有：

* 默认参数要在函数的声明中赋值
* 默认参数右面的参数全应该有默认值
* 实参从左往右赋给相应形参，不允许跳过任何参数

实现方式如下：

```C++
int add1(int n = 1, int m = 2, int j =3);  //正确
int add2(int n, int m =2, int j =3); //正确
int add3(int n, int m = 2, int j); //错误，右侧没有默认参数
add2(2,3);  //2 + 2 +3
add2(2, ,3); //错误
```

## 3.函数的变量引用

### 3.1引用的要点

以下几点需要注意：

* 变量引用是给变量起一个别名
* 变量引用多用于形参
* 引用使用符号&，通常作为被赋值方
* 引用声明时必须初始化
* 引用定义后就与变量绑定，等效于int * const rf = &var;
* 引用后的赋值号相当于对原变量的赋值

### 3.2引用作为函数形参

```C++
//函数声明过程
int swap(int &a, int &b);

//函数的使用
int a = 1;
int b = 2;
swap(a , b);
```

对于需要修改实参值的函数，使用引用和使用指针都能满足要求，两者也有一些不同之处。

方式|声明方式类似|调用方式不同
----|----|----
引用|swap(int &a,int &b);|swap(a,b);
指针|swap(int *a,int *b);|swap(&a,&b);

### 3.3引用与const关键字

在不需要改变引用的值的时候，尽可能使用const作为函数形参的关键字。

好处：

* 统一处理const和非const的实参
* 避免程序编写错误导致参数发生变化
* 在实参不是引用的时候能够正确的生成临时变量

临时变量是指当函数的形参为const常量且实参类型不是引用类型的时候自动生成的变量。**临时变量只在函数调用期间存在**。

两种情况会生成临时变量：

* 实参类型正确，但不是左值：如表达式、函数返回值等
* 实参类型不正确，但可以转换成正确类型：如long转double等

此外，C++11中还新增了右值引用，使用两个&(即&&)实现。

### 3.4引用用于结构体和类

引用的引入主要就是为了用于结构体和类等复杂结构，**在使用过程中结构体和类的引用与基本变量的引用相同**。

### 3.5函数的引用返回值与const

使用方式如下
```C++
const int & fun(const int &var);
```

* 函数返回值的引用要注意不能返回临时变量或者局部变量等函数结束后自动释放的变量的引用
* 由于引用是一个左值，可以进行赋值，使用const是为了出现fun(2) = 1这种失误
