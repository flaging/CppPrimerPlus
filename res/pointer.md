# [pointer]指针的用法
指针的策略与基于值的程序设计方法正好相反，将地址视为指定的量，将值视为派生的量。
## 1.指针的声明和初始化
声明方式如下
```C++
int *p1;
char *p2;
double*p3;
int* p4,p5;
```
这里，int* 为复合类型，即指向int型的指针。
初始化及赋值方式如下
```C++
int age = 4;
int *p6 = &age;
int *p7 = new int;
char *p9 = "hello";
int *p10;
p10 = (int *)0xB8000000;
int *p11 = p9;
```
这里，&是对变量取地址的操作，*后跟地址是取地址内容的操作，另外 *也可以作为形参出现在函数定义过程中，这个时候起到的是引用的作用。
>引用和取地址的区别：引用在实际使用时候参数为该变量的名字就可以，而在取地址过程中参数只能某一变量的地址。
    
在使用指针变量的过程中，一个关键问题是指针一定要初始化，不经初始化或者赋值的指针在使用过程中可能会引起程序出错。 
## 2.变量的释放   
在使用new命令的时候，一定要使用delete函数对其进行释放。delete的使用有如下几个特点：
* 只能作用于使用new声明的区域，变量名声明的方法的区域不能使用
* 只是删除该部分的内存，并不对指针进行任何操作
## 3.创建动态数组
动态数组的声明和释放。
```C++
char *p8 = new char[10]; 
delete [] p8;
```
## 4.数组名与指针的差别
```C++
int *p12[] = {2,3,4,5}; //p12是数组名
int *p13 = p12;  //p13是指针
```
数组名是不能进行自加操作的，只能指向数组的第一个元素，而指针没有这一限制。  
在使用sizeof()函数对数组名和指向数组的时候，返回值为该数组整体的大小；而指向数组的指针在进行相同操作的时候返回该指针指向的一个变量的大小。
## 5.数组指针的特性
指向数组的指针还有一些其他的特性。
* *(pointer + i)与 *(arrayname + i)几乎可以等效
* 执行pointer = pointer + i 操作的时候，其地址增加量为指向类型的占用的字节数
* 在同一个数组的两个指针可以进行相减运算，得到的值为整数
* 使用new产生的数组动态联编，而传统方式是静态联编
* 当cout的输入为字符串指针的时候，cout直至空字符才停止
>上文第二点所表示的意思是，数组名代表整个数组，而指针只能代表指向的一小部分区域。
## 6.new的其他用法
在使用new动态联编得到内存的时候，其返回值是一个指针，这种方法不止在基本数据类型中可用，在新建结构体对象的时候也是可用的。
```C++
struct person{
    char name[20];
    int age;
};
person *p = new person;
p -> name = "xiaoming";
p -> age = 19;
delete p;
```
## 7.变量存储方式
存储方式 | 作用域 | 实现方法 |定义方法
---- | ----- | ----- | ----
自动存储 | 局部变量 | 存储在栈中，作用域为其包含的整个代码块 | 传统变量定义方法
静态存储 | 全局变量、常变量、静态变量 | 编译时期就确定好 | 使用static/const关键字进行限定或者在函数外部定义
动态存储 |  | 在自由存储空间或者堆中，与上述两种变量不在同一内存区域，其生命周期不受限制 | new/delete


